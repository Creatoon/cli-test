"use strict";
/*

* About File:

    defines a package and its routines, a package is just a metacall.json with some extra details, for example, the runners needed to build a it (for example, if we find a requirements.txt then it means we need to run the python installer pip, so the python runner is needed)

    it includes ignore files (like .gitignore), it is able to list all files in a path and classify them depending on what loader is the correct for each file extension

    generatePackage is an exported function that given a path it generates all the information needed, for example, what runners are needed, what metacall-*.json are generated (depending on file extension) and the list of files that will be in that package (excluding the ones in gitignore)

    generateJsonsFromFiles is similar but it is more fine grained, it uses a list of files and returns what are the metacall-*.json generated from them

*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateJsonsFromFiles = exports.generatePackage = exports.PackageError = exports.findRunners = exports.findMetaCallJsons = exports.findFilesPath = void 0;
const ignore_walk_1 = __importDefault(require("ignore-walk"));
const path_1 = require("path");
const language_1 = require("./language");
const findFilesPath = async (path = process.cwd(), ignoreFiles = ['.gitignore']) => (await (0, ignore_walk_1.default)({
    path,
    ignoreFiles,
    includeEmpty: false,
    follow: true
})).filter(x => !x.startsWith('.git'));
exports.findFilesPath = findFilesPath;
const pathIsMetaCallJson = (path) => !!/^metacall(-.+)?\.json$/.exec((0, path_1.basename)(path));
const findMetaCallJsons = (files) => files.filter(pathIsMetaCallJson);
exports.findMetaCallJsons = findMetaCallJsons;
const findRunners = (files) => {
    const runners = new Set();
    for (const file of files) {
        const fileName = (0, path_1.basename)(file);
        for (const langId of Object.keys(language_1.Languages)) {
            const lang = language_1.Languages[langId];
            for (const re of lang.runnerFilesRegexes) {
                if (re.exec(fileName) && lang.runnerName) {
                    runners.add(lang.runnerName);
                }
            }
        }
    }
    return runners;
};
exports.findRunners = findRunners;
var PackageError;
(function (PackageError) {
    PackageError["Empty"] = "No files found in the current folder";
    PackageError["JsonNotFound"] = "No metacall.json found in the current folder";
    PackageError["None"] = "Package correctly generated";
})(PackageError = exports.PackageError || (exports.PackageError = {}));
const NullPackage = {
    error: PackageError.None,
    files: [],
    jsons: [],
    runners: []
};
const generatePackage = async (path = process.cwd()) => {
    const files = await (0, exports.findFilesPath)(path);
    if (files.length === 0) {
        return { ...NullPackage, error: PackageError.Empty };
    }
    const jsons = (0, exports.findMetaCallJsons)(files);
    return {
        error: jsons.length === 0 ? PackageError.JsonNotFound : PackageError.None,
        files,
        jsons,
        runners: Array.from((0, exports.findRunners)(files))
    };
};
exports.generatePackage = generatePackage;
const getExtension = (file) => {
    const ext = (0, path_1.extname)(file || '').split('.');
    return ext[ext.length - 1];
};
const matchFilesByLanguage = (lang, files) => files.reduce((arr, file) => language_1.Languages[lang].fileExtRegex.exec(getExtension(file) || (0, path_1.basename)(file))
    ? [...arr, file]
    : arr, []);
const generateJsonsFromFiles = (files) => Object.keys(language_1.Languages).reduce((jsons, lang) => {
    const scripts = matchFilesByLanguage(lang, files);
    if (scripts.length === 0) {
        return jsons;
    }
    else {
        return [
            {
                language_id: lang,
                path: '.',
                scripts
            },
            ...jsons
        ];
    }
}, []);
exports.generateJsonsFromFiles = generateJsonsFromFiles;
